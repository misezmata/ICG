Line 1: type_specifier : INT

int

Line 1: type_specifier : INT

int

Line 1: parameter_list : type_specifier ID

int a

Line 2: variable : ID

a

Line 2: factor : variable

a

Line 2: unary_expression : factor

a

Line 2: term : unary_expression

a

Line 2: simple_expression : term

a

Line 2: factor : CONST_INT

1

Line 2: unary_expression : factor

1

Line 2: term : unary_expression

1

Line 2: simple_expression : term

1

Line 2: rel_expression : simple_expression RELOP simple_expression

a==1

Line 2: variable : ID

a

Line 2: factor : variable

a

Line 2: unary_expression : factor

a

Line 2: term : unary_expression

a

Line 2: simple_expression : term

a

Line 2: factor : CONST_INT

2

Line 2: unary_expression : factor

2

Line 2: term : unary_expression

2

Line 2: simple_expression : term

2

Line 2: rel_expression : simple_expression RELOP simple_expression

a==2

Line 2: logic_expression : rel_expression LOGICOP rel_expression

a==1||a==2

Line 2: expression : logic_expression

a==1||a==2

Line 2: factor : CONST_INT

1

Line 2: unary_expression : factor

1

Line 2: term : unary_expression

1

Line 2: simple_expression : term

1

Line 2: rel_expression : simple_expression

1

Line 2: logic_expression : rel_expression

1

Line 2: expression : logic_expression

1

Line 2: statement : RETURN expression SEMICOLON

return 1;


Line 3: statement : IF LPAREN expression RPAREN statement

if (a==1||a==2)return 1;


Line 3: statements : statement

if (a==1||a==2)return 1;


Line 3: variable : ID

a

Line 3: factor : variable

a

Line 3: unary_expression : factor

a

Line 3: term : unary_expression

a

Line 3: simple_expression : term

a

Line 3: factor : CONST_INT

1

Line 3: unary_expression : factor

1

Line 3: term : unary_expression

1

Line 3: simple_expression : simple_expression ADDOP term

a-1

Line 3: rel_expression : simple_expression

a-1

Line 3: logic_expression : rel_expression

a-1

Line 3: arguments : logic_expression

a-1

Line 3: argument_list : arguments

a-1

Line 3: factor : ID LPAREN argument_list RPAREN

fib(a-1)

Line 3: unary_expression : factor

fib(a-1)

Line 3: term : unary_expression

fib(a-1)

Line 3: simple_expression : term

fib(a-1)

Line 3: variable : ID

a

Line 3: factor : variable

a

Line 3: unary_expression : factor

a

Line 3: term : unary_expression

a

Line 3: simple_expression : term

a

Line 3: factor : CONST_INT

2

Line 3: unary_expression : factor

2

Line 3: term : unary_expression

2

Line 3: simple_expression : simple_expression ADDOP term

a-2

Line 3: rel_expression : simple_expression

a-2

Line 3: logic_expression : rel_expression

a-2

Line 3: arguments : logic_expression

a-2

Line 3: argument_list : arguments

a-2

Line 3: factor : ID LPAREN argument_list RPAREN

fib(a-2)

Line 3: unary_expression : factor

fib(a-2)

Line 3: term : unary_expression

fib(a-2)

Line 3: simple_expression : simple_expression ADDOP term

fib(a-1)+fib(a-2)

Line 3: rel_expression : simple_expression

fib(a-1)+fib(a-2)

Line 3: logic_expression : rel_expression

fib(a-1)+fib(a-2)

Line 3: expression : logic_expression

fib(a-1)+fib(a-2)

Line 3: statement : RETURN expression SEMICOLON

return fib(a-1)+fib(a-2);


Line 3: statements : statements statement

if (a==1||a==2)return 1;
return fib(a-1)+fib(a-2);


Line 4: compound_statement : LCURL statements RCURL

{
if (a==1||a==2)return 1;
return fib(a-1)+fib(a-2);
}




ScopeTable # 1.1
 6 --> < a , ID > 



ScopeTable # 1
 0 --> < fib , ID > 


Line 4: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement

int fib(int a){
if (a==1||a==2)return 1;
return fib(a-1)+fib(a-2);
}


Line 4: unit : func_definition

int fib(int a){
if (a==1||a==2)return 1;
return fib(a-1)+fib(a-2);
}



Line 4: program : unit

int fib(int a){
if (a==1||a==2)return 1;
return fib(a-1)+fib(a-2);
}



Line 6: type_specifier : INT

int

Line 7: type_specifier : INT

int

Line 7: declaration_list : ID

a

Line 7: var_declaration : type_specifier declaration_list SEMICOLON

int a;

Line 7: statement : var_declaration

int a;


Line 7: statements : statement

int a;


Line 8: variable : ID

a

Line 8: factor : CONST_INT

1

Line 8: unary_expression : factor

1

Line 8: term : unary_expression

1

Line 8: simple_expression : term

1

Line 8: rel_expression : simple_expression

1

Line 8: logic_expression : rel_expression

1

Line 8: expression : variable ASSIGNOP logic_expression

a=1

Line 8: expression_statement : expression SEMICOLON

a=1;

Line 8: variable : ID

a

Line 8: factor : variable

a

Line 8: unary_expression : factor

a

Line 8: term : unary_expression

a

Line 8: simple_expression : term

a

Line 8: factor : CONST_INT

10

Line 8: unary_expression : factor

10

Line 8: term : unary_expression

10

Line 8: simple_expression : term

10

Line 8: rel_expression : simple_expression RELOP simple_expression

a<10

Line 8: logic_expression : rel_expression

a<10

Line 8: expression : logic_expression

a<10

Line 8: expression_statement : expression SEMICOLON

a<10;

Line 8: variable : ID

a

Line 8: factor : variable INCOP

a++

Line 8: unary_expression : factor

a++

Line 8: term : unary_expression

a++

Line 8: simple_expression : term

a++

Line 8: rel_expression : simple_expression

a++

Line 8: logic_expression : rel_expression

a++

Line 8: expression : logic_expression

a++

Line 9: type_specifier : INT

int

Line 9: declaration_list : ID

c

Line 9: var_declaration : type_specifier declaration_list SEMICOLON

int c;

Line 9: statement : var_declaration

int c;


Line 9: statements : statement

int c;


Line 10: variable : ID

c

Line 10: variable : ID

a

Line 10: factor : variable

a

Line 10: unary_expression : factor

a

Line 10: term : unary_expression

a

Line 10: simple_expression : term

a

Line 10: rel_expression : simple_expression

a

Line 10: logic_expression : rel_expression

a

Line 10: arguments : logic_expression

a

Line 10: argument_list : arguments

a

Line 10: factor : ID LPAREN argument_list RPAREN

fib(a)

Line 10: unary_expression : factor

fib(a)

Line 10: term : unary_expression

fib(a)

Line 10: simple_expression : term

fib(a)

Line 10: rel_expression : simple_expression

fib(a)

Line 10: logic_expression : rel_expression

fib(a)

Line 10: expression : variable ASSIGNOP logic_expression

c=fib(a)

Line 10: expression_statement : expression SEMICOLON

c=fib(a);

Line 10: statement : expression_statement

c=fib(a);


Line 10: statements : statements statement

int c;
c=fib(a);


Line 11: statement : PRINTLN LPAREN ID RPAREN SEMICOLON

printf(c);


Line 11: statements : statements statement

int c;
c=fib(a);
printf(c);


Line 12: compound_statement : LCURL statements RCURL

{
int c;
c=fib(a);
printf(c);
}




ScopeTable # 1.2.1
 1 --> < c , ID > 



ScopeTable # 1.2
 6 --> < a , ID > 



ScopeTable # 1
 0 --> < fib , ID > 
 6 --> < main , ID > 


Line 12: statement : compound_statement

{
int c;
c=fib(a);
printf(c);
}


Line 12: statement : FOR LPAREN expression_statement expression_statement expression RPAREN statement

for(a=1;a<10;a++){
int c;
c=fib(a);
printf(c);
}


Line 12: statements : statements statement

int a;
for(a=1;a<10;a++){
int c;
c=fib(a);
printf(c);
}


Line 13: compound_statement : LCURL statements RCURL

{
int a;
for(a=1;a<10;a++){
int c;
c=fib(a);
printf(c);
}
}




ScopeTable # 1.2
 6 --> < a , ID > 



ScopeTable # 1
 0 --> < fib , ID > 
 6 --> < main , ID > 


Line 13: func_definition : type_specifier ID LPAREN RPAREN compound_statement

Error at line 13: Type mismatch, function is not void

int main(){
int a;
for(a=1;a<10;a++){
int c;
c=fib(a);
printf(c);
}
}


Line 13: unit : func_definition

int main(){
int a;
for(a=1;a<10;a++){
int c;
c=fib(a);
printf(c);
}
}



Line 13: program : program unit

int fib(int a){
if (a==1||a==2)return 1;
return fib(a-1)+fib(a-2);
}

int main(){
int a;
for(a=1;a<10;a++){
int c;
c=fib(a);
printf(c);
}
}



Line 13: start : program



ScopeTable # 1
 0 --> < fib , ID > 
 6 --> < main , ID > 


Total lines: 13
Total errors: 1

